- Java and Java 1.8 Features:

  - Oops concepts:
    - Abstraction: Hiding the implementation and showing only the essential details.
    - Polymorphism: It means many form. Functions with same signature and different parameters.
    - Encapsulation: 
       - Binding of data and the code that manipulates it. private variable and get set methods. 
       - It protects the data from being accessed by outside.
    - Inheritance: A mechanism in which one java class inherits the property of other class.
  
  - Threads:
    - implement Runnable interface or extend Thread class to create threads.
    - Use runnable because you can extend other class. If you use Thread class then you cannot extends any class.
    - Executor framework for creating thread pools. 
    - The callable interface was introduced in concurrency package, which is similar to the Runnable interface, 
      but it can return any object, and is able to throw an Exception. The Java Callable interface uses Generics,
      so it can return any type of Object.

    - Daemon Thread: 
      - Daemon thread in Java is a low-priority thread that runs in the background to perform tasks such as garbage collection. 
      - Daemon thread in Java is also a service provider thread that provides services to the user thread. Its life depends on the mercy of user threads 
        i.e. when all the user threads die, JVM terminates this thread automatically.

    - Methods:  
      - start() : start the thread
      - Join() : Stop the current thread until the called thread gets terminated.
      - currentThread() : return reference to currently executing thread, Thread.currentThread() 
      - getName() : return name of thread
      
    - Life cycle of thread:
      - New: when new thread is created
      - Active: When it invokes start method
      - Runnable: thread which is ready to run is moved to runnable
      - Running: When thread gets the cpu
      - Blocked or waiting: when thread is inactive for a span of time
        
  - Lambda Expressions:
    - lambda expressions help us to write code in functional style.
      It provides a clear and concise way to implement SAM interface
      (Single Abstract Method). E.g., Collections comparator

      Syntax - (a,b) -> {}
    
    - Why Lambda:
      - To provide the implementation of Functional interface
      - Less Coding
    
  - Functional Interface:
    - An interface that contains only one abstract method also known as SAM.
    - It can have any number of static and default methods.
    - '@FunctionalInterface to declare the interface'
  
  - Optional:
    - It is a public final class which is used to deal with NullPointerException in Java application.
    - import java.util
    - By using Optional, we can specify alternate values to return or alternate code to run. This makes the code
      more readable because the facts which were hidden are now visible to the developer.

  - forEach:
    - Java provides a new method forEach() to iterate the elements. 
      It is defined in Iterable and Stream interfaces.
    
  - Default Methods:
    - Java provides a facility to create default methods inside the interface.
    - code | 
        interface Sayable{  
          default void say(){  
              System.out.println("Hello, this is default method");  
          }   
          void sayMore(String msg);  
        }  
  
  - Stream Api:
    - Java 8 java.util.stream package consists of classes, 
      interfaces and an enum to allow functional-style operations
      on the elements. It performs lazy computation. 
      So, it executes only when it requires.
  
  - Java Base64 Encoding and Decoding:
    - Java provides a class Base64 to deal with encryption and decryption. 
      You need to import java.util.Base64 class in your source file to use 
      its methods.


- Spring Boot:
  - Spring Boot makes it easy to create stand-alone, production-grade Spring
    based Applications that you can "just run".
  - Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)
  - Provide opinionated 'starter' dependencies to simplify your build configuration
  - Automatically configure Spring and 3rd party libraries whenever possible
  - Provide production-ready features such as metrics, health checks, and externalized configuration
  - Absolutely no code generation and no requirement for XML configuration

  - Features of spring boot:  
    - Starter dependency: With the help of this feature, it aggregates common dependencies together and eventually improves productivity.
    - Auto-configuration: It helps in loading the default configurations according to the project you are working on. In this way, you 
                          can avoid any unnecessary WAR files. 

    - Spring Actuator: 
      - This feature provides help while running spring boot applications.
      - when you want to debug your application, Spring actuator provides easy access to features such as identifying beans, CPU usage etc.
      - It provides a very easy way to access the production-ready REST points and fetch all kind of information from web.
      - It exposes several rest endpoints like info, health, metrics, trace, env etc. 
  
  - Spring IOC:
    - Spring IoC Container is the core of Spring Framework. 
      It creates the objects, configures and assembles their dependencies,
      manages their entire life cycle. The Container uses Dependency Injection(DI)
      to manage the components that make up the application.
  
  - Bean and Bean scopes:
    - Beans are java singleton objects that a spring boot context managers.
    - Scopes:
      - Singleton (Default) : Only one instance of bean is creted.
      - Prototype: Returns different instance every time

    - Use: '@Bean @Scope("singleton / prototype")'
  
  - JPA (Java Persistence API):
    - The Java Persistence API (JPA) is a specification of Java. It is used to persist data between Java
      object and relational database. JPA acts as a bridge between object-oriented domain models and relational
      database systems. As JPA is just a specification, it doesn't perform any operation by itself.
      Therefore, it needs implementation. Hence, for data persistence ORM tools like Hibernate implements JPA specifications.

    - If you map various model classes to the database, then JPA can a) generate an appropriate SQL query/update,
      b) convert the resultsets to the model classes. JPA also includes caching, and abstracts transaction handling.

  - Hibernate Framework:
    - Hibernate's primary feature is mapping from Java classes to database tables, and mapping from Java data types
      to SQL data types. Hibernate also provides data query and retrieval facilities. It generates SQL calls and relieves
      the developer from the manual handling and object conversion of the result set.

    - The main feature of Hibernate is to map the Java classes to database tables. Following are some key features of Hibernate:
      - Hibernate is an implementation of JPA guidelines.
      - It helps in mapping Java data types to SQL data types.
      - It is the contributor of JPA.
    
  - Difference between Hibarnate and JPA:
    - JPA is just an specification. It gives common functionality and prototype to ORM tools. 
    - Hibernate is an ORM tool that follow the common standards, by executing the same specification.
    - We use JPA because if we switch ORM then function will work as it is working with hibernate.

  - MongoTemplate:
    - The MongoTemplate class is the primary implementation of MongoOperations interface which specifies the basic set of MongoDB operations. 
    - We can also use MongoRepository interface to perform MongoDB operations.
    - The implementation class of MongoRepository uses MongoTemplate bean at run time.
    
  - Maven:
    - Maven is a powerful project management tool that is based on POM (project object model). It is used for projects build, dependency and documentation. It simplifies the build process
  
  - Dependency Injection in Spring:
    - Dependency Injection is a fundamental aspect of the Spring framework, through which the Spring container “injects” objects into other objects or “dependencies”. 
    - Simply put, this allows for loose coupling of components and moves the responsibility of managing components onto the container.

    



    

